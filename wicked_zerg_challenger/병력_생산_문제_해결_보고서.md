# 병력 생산 문제 원인 분석 및 해결 보고서

## 📋 문제 개요
봇이 게임 중에 병력(유닛)을 생산하지 못하는 문제가 발생했습니다. 로그 분석 결과, 여러 가지 런타임 에러가 병력 생산 로직을 중단시키고 있었습니다.

---

## 🔍 발견된 주요 문제들

### 1. **KeyError: 901** (Invalid UnitTypeId)
**위치**: `production_manager.py` - `_autonomous_tech_progression()` 함수

**원인**:
- 기술 건물 큐에 잘못된 `UnitTypeId` (예: 901)가 포함되어 있었습니다.
- `b.already_pending(tid)` 또는 `b.structures(tid).exists` 호출 시 존재하지 않는 유닛 ID로 인해 `KeyError`가 발생했습니다.
- 이 에러로 인해 기술 건물 건설 로직이 중단되고, 결과적으로 고급 유닛 생산이 불가능해졌습니다.

**해결 방법**:
```python
# 수정 전
if b.structures(tid).exists or b.already_pending(tid) > 0:
    continue

# 수정 후
try:
    if b.structures(tid).exists or b.already_pending(tid) > 0:
        continue
except (KeyError, AttributeError) as e:
    # Invalid UnitTypeId (e.g., 901) - skip this building
    current_iteration = getattr(b, "iteration", 0)
    if current_iteration % 200 == 0:
        print(f"[WARNING] Invalid UnitTypeId in tech queue: {tid} (error: {e})")
    continue
```

**효과**: 잘못된 유닛 ID가 있어도 건물 건설 로직이 계속 진행됩니다.

---

### 2. **TypeError: object bool can't be used in 'await' expression**
**위치**: `production_manager.py` - 여러 함수 (`_produce_overlord()`, `_flush_resources()`, `_aggressive_unit_production()`)

**원인**:
- `larvae` 변수가 때때로 `Units` 객체나 `bool` 값으로 반환될 수 있습니다.
- `random.choice(larvae)`를 호출할 때 `larvae`가 리스트가 아니면 `TypeError`가 발생했습니다.
- 특히 `intel.cached_larva`를 사용할 때 `Units` 객체가 반환되어 문제가 발생했습니다.

**해결 방법**:
```python
# 수정 전
if b.can_afford(UnitTypeId.OVERLORD) and larvae:
    await random.choice(larvae).train(UnitTypeId.OVERLORD)

# 수정 후
if b.can_afford(UnitTypeId.OVERLORD) and larvae:
    # Convert larvae to list if needed
    larva_list = list(larvae) if hasattr(larvae, '__iter__') and not isinstance(larvae, bool) else []
    if len(larva_list) > 0:
        await random.choice(larva_list).train(UnitTypeId.OVERLORD)
```

**효과**: `larvae`가 어떤 타입이든 안전하게 리스트로 변환되어 유닛 생산이 정상적으로 진행됩니다.

---

### 3. **AttributeError: 'NoneType' object has no attribute 'exact_id'**
**위치**: `production_manager.py` - `_research_mandatory_upgrades()` 함수

**원인**:
- `getattr(UpgradeId, "ZERGLINGMOVEMENTSPEED", None)` 같은 코드에서 업그레이드 ID가 존재하지 않으면 `None`이 반환됩니다.
- `None` 값이 `candidate_upgrades` 리스트에 포함되어 `b.already_pending_upgrade(upg)` 호출 시 에러가 발생했습니다.

**해결 방법**:
```python
# 수정 전
candidate_upgrades = [
    getattr(UpgradeId, "ZERGLINGMOVEMENTSPEED", None),
    # ... other upgrades ...
]
for upg in candidate_upgrades:
    if upg and b.already_pending_upgrade(upg) > 0:
        pending_any = True
        break

# 수정 후
candidate_upgrades = [
    getattr(UpgradeId, "ZERGLINGMOVEMENTSPEED", None),
    # ... other upgrades ...
]
# Filter out None values
candidate_upgrades = [upg for upg in candidate_upgrades if upg is not None]
pending_any = False
for upg in candidate_upgrades:
    try:
        if upg and b.already_pending_upgrade(upg) > 0:
            pending_any = True
            break
    except (AttributeError, KeyError) as e:
        # Invalid upgrade ID - skip
        current_iteration = getattr(b, "iteration", 0)
        if current_iteration % 200 == 0:
            print(f"[WARNING] Invalid UpgradeId: {upg} (error: {e})")
        continue
```

**효과**: 잘못된 업그레이드 ID가 있어도 업그레이드 연구 로직이 계속 진행됩니다.

---

### 4. **_aggressive_unit_production() 함수의 larvae 타입 문제**
**위치**: `production_manager.py` - `_aggressive_unit_production()` 함수

**원인**:
- `intel.cached_larva`에서 `Units` 객체를 받아올 때, 이를 리스트로 변환하지 않고 `random.choice()`에 전달했습니다.
- `Units` 객체는 `random.choice()`에 직접 사용할 수 없어 에러가 발생했습니다.

**해결 방법**:
```python
# 수정 전
if intel and intel.cached_larva is not None:
    larvae = (
        intel.cached_larva.ready
        if hasattr(intel.cached_larva, "ready")
        else intel.cached_larva
    )
    if not larvae.exists:
        return False
# ... later ...
await random.choice(larvae).train(UnitTypeId.OVERLORD)  # ❌ 에러 발생

# 수정 후
if intel and intel.cached_larva is not None:
    larvae_raw = (
        intel.cached_larva.ready
        if hasattr(intel.cached_larva, "ready")
        else intel.cached_larva
    )
    if not larvae_raw.exists:
        return False
    # Convert Units object to list
    larvae = list(larvae_raw)  # ✅ 리스트로 변환
# ... later ...
larva_list = list(larvae) if hasattr(larvae, '__iter__') and not isinstance(larvae, bool) else []
if len(larva_list) > 0:
    await random.choice(larva_list).train(UnitTypeId.OVERLORD)  # ✅ 안전하게 사용
```

**효과**: `larvae`가 항상 리스트 형태로 처리되어 유닛 생산이 안정적으로 진행됩니다.

---

## ✅ 수정 완료 사항

1. ✅ `KeyError: 901` 처리 - `_autonomous_tech_progression()` 함수에 `try-except` 블록 추가
2. ✅ `TypeError` 처리 - 모든 `random.choice(larvae)` 호출 전에 리스트 변환 로직 추가
3. ✅ `AttributeError` 처리 - `_research_mandatory_upgrades()` 함수에서 `None` 값 필터링 및 예외 처리 추가
4. ✅ `_aggressive_unit_production()` 함수의 `larvae` 타입 변환 수정

---

## 🎯 예상 효과

이제 봇은 다음과 같은 상황에서도 병력을 정상적으로 생산할 수 있습니다:

1. **잘못된 유닛 ID가 기술 큐에 포함되어 있어도** → 건물 건설 로직이 계속 진행됩니다.
2. **larvae가 Units 객체로 반환되어도** → 자동으로 리스트로 변환되어 사용됩니다.
3. **존재하지 않는 업그레이드 ID가 있어도** → 업그레이드 연구 로직이 계속 진행됩니다.
4. **예상치 못한 타입의 데이터가 들어와도** → 예외 처리로 봇이 크래시하지 않습니다.

---

## 📝 추가 권장 사항

1. **로깅 강화**: 병력 생산 실패 시 더 자세한 로그를 남겨 디버깅을 용이하게 합니다.
2. **모니터링**: 게임 중 실제로 유닛이 생산되는지 모니터링하여 추가 문제를 조기에 발견합니다.
3. **테스트**: 다양한 게임 상황에서 봇을 실행하여 모든 수정 사항이 정상 작동하는지 확인합니다.

---

## 🔄 다음 단계

1. 게임을 실행하여 병력 생산이 정상적으로 이루어지는지 확인
2. 로그를 모니터링하여 추가 에러가 없는지 확인
3. 필요시 추가 최적화 및 개선 작업 진행

---

**작성일**: 2026-01-15  
**수정 파일**: `wicked_zerg_challenger/production_manager.py`
